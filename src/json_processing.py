"""
 json_processing.py

  Created by Julien Zouein on 10/11/2023.
  Copyright © 2023 Sigmedia.tv. All rights reserved.
  Copyright © 2023 Julien Zouein (zoueinj@tcd.ie)
----------------------------------------------------------------------------

Define all the functions needed to process the json files generated by AOM inspection tool.
"""
from typing import Tuple

import cv2
import numpy as np

import json


def read_json_file(json_file: str) -> dict:
    """
    Read the json file and return the dictionary containing the data
    :param json_file: json file to read
    :return: dictionary containing the data
    """
    with open(json_file, "r") as file:
        data = json.loads(file.read())
    return data


def get_frame_data(data: dict, frame_number: int) -> dict:
    """
    Get the data of a specific frame
    :param data: dictionary containing the data
    :param frame_number: frame number
    :return: dictionary containing the data of the frame
    """
    return data[frame_number]


def get_frame_motion_vectors(
        frame_data: dict,
        reference_dict: dict,
        frame_number: int
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Get the motion vector map of a specific frame and the motion intensity map.
    :param frame_data: dictionary containing the data of the frame
    :param reference_dict: dictionary containing the mapping of the reference frames
    :param frame_number: Frame number
    :return: a 2-channels numpy array creating the vector motion field
    """

    motion_vectors = frame_data["motionVectors"]
    reference_frames = frame_data["referenceFrame"]

    h = len(motion_vectors)
    w = len(motion_vectors[0])

    motion_map = np.zeros((h*4, w*4, 2), dtype=np.float32)
    motion_map_projection = np.zeros((h * 4, w * 4, 2), dtype=np.float32)
    reference_map = np.zeros((h*4, w*4, 1), dtype=np.float32)

    for i in range(0, h-1):
        for j in range(0, w-1):

            vector_h = -(motion_vectors[i][j][0])/16
            vector_w = -(motion_vectors[i][j][1])/16

            motion_map[i*4:(i+1)*4, j*4:(j+1)*4, 0] = vector_w
            motion_map[i*4:(i+1)*4, j*4:(j+1)*4, 1] = vector_h

            reference_map[i * 4:(i + 1) * 4, j * 4:(j + 1) * 4, 0] = reference_frames[i][j][0] / 7

            reference_frame = reference_frames[i][j][0]
            reference_frame_number = reference_dict[reference_frame]
            distance = frame_number - reference_frame_number

            motion_map_projection[i * 4:(i + 1) * 4, j * 4:(j + 1) * 4, 0] = vector_w / distance
            motion_map_projection[i * 4:(i + 1) * 4, j * 4:(j + 1) * 4, 1] = vector_h / distance

    reference_map = reference_map * 255
    reference_map = reference_map.astype(np.uint8)

    return motion_map, motion_map_projection, reference_map


def get_frame_reference(frame_data: dict) -> np.ndarray:
    """Get the reference frames used for each block in a specific frame

    :param frame_data: dictionary containing the data of the frame
    :return: numpy array containing the reference frame
    """
    reference_frames = frame_data["referenceFrame"]

    h = len(reference_frames)
    w = len(reference_frames[0])

    result = np.zeros((h*4, w*4, 1), dtype=np.float32)

    for i in range(0, h-1):
        for j in range(0, w-1):

            result[i*4:(i+1)*4, j*4:(j+1)*4, 0] = reference_frames[i][j][0]/7

    result = result * 255
    result = result.astype(np.uint8)

    return result
